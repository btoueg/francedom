<!DOCTYPE html>
<head>
<style>

svg, canvas {
	display: block;
	position: absolute;
}

.border-outer {
	stroke: lightblue;
	stroke-width: 8px;
	fill: none;
}
.border {
	stroke: #449;
	stroke-width: 1px;
	fill: lightyellow;
	cursor: help;
}

.FRA {
	fill: lightgreen;
}

.prefecture-label {
	font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
	font-weight: bold;
	font-size: 14px;
	fill: black;
	stroke: lightgrey;
	stroke-width: 0.6px;
}

</style>
</head>
<body>

<script src="d3.v3.min.js"></script>
<script src="topojson.v1.js"></script>
<script src="queue.v1.min.js"></script>
<script src="francedom.js"></script>

<script>

var width = window.innerWidth - 30,
    height = window.innerHeight + 80;

var projection = d3.geo.franceDom();

var svg = d3.select("body").append("svg")
	.attr("width", width)
	.attr("height", height)
	.style("z-index", "-1");

var canvas = d3.select("body").append("canvas")
	.style("z-index", "0")
    .attr("width", width)
    .attr("height", height)[0][0].getContext('2d');

var path = d3.geo.path()
	.projection(projection);

queue()
    .defer(d3.json, "france-dom-tom.topojson")
    .defer(d3.json, "territoires-communes.topojson")
    .defer(d3.tsv, "communes.tsv")
    .await(function(error, borders, communes, coord) {
		d3.map(borders.objects).values().forEach(function(o) {
			var topo = topojson.feature(borders, o).features;

			svg.selectAll(".border")
				.data(topo).enter().append('path')
				.attr("class", "border-outer")
				.attr("d", path);

			svg.selectAll(".border2")
				.data(topo).enter().append('path')
				.attr("class", function(d) { return "border " + d.properties.adm0_a3; })
				.attr("d", path)
				.append('title')
					.text(function(d) { return d.properties.admin; })
		});

		var points = coord.filter(function(d) {
			// Display labels for all prefectures, (sub)antarctic bases, and Clipperton.
			if (d.chef_lieu_region == 1 || (d.chef_lieu_departement == 1 && d.departement > 900) || d.departement == 989) {
				d.xy = projection([+d.longitude, +d.latitude]);
				if (d.xy) { return true; }
			}

			return false;
		});
		svg.selectAll(".prefecture")
			.data(points)
			.enter().append("circle")
				.attr("class", "prefecture")
				.attr("r", "2")
				.attr("cx", function(d) { return d.xy[0]; })
				.attr("cy", function(d) { return d.xy[1]; });

		svg.selectAll(".prefecture-label")
			.data(points)
			.enter().append("text")
				.attr("class", "prefecture-label")
				.attr("dy", "0.35em")
				.style("text-anchor", function(d) {
					d.xoffset = +5;
					d.yoffset = -5;
					// Some exceptions to nicely position labels.
					switch (+d.departement) {
						case 21:
							d.xoffset = -5;
							return "end";
						case 51:
							d.yoffset = 0;
							return "start";
						case 57:
						case 69:
							d.yoffset = -7;
							return "start";
						case 25:
						case 67:
							d.yoffset = +5;
							return "start";
						case 63:
							d.xoffset = -5;
							d.yoffset = +8;
							return "middle";
						case 87:
							d.xoffset = -5;
							return "end";
						case 975:
							d.xoffset =  0;
							d.yoffset = +9;
							return "middle";
						case 984:
							d.xoffset =  0;
							d.yoffset = -7;
							return "middle";
						case 976:
						case 986:
							d.xoffset = -5;
							return "end";
						default:
							return "start";
					}
				})
				.attr("transform", function(d) { return "translate(" + [d.xy[0] + d.xoffset, d.xy[1] + d.yoffset] + ")"; })
				.text(function(d) { return d.nom_point ? d.nom_point : d.nom; });

		var drawCommunes = function(data) {
			canvas.clearRect(0, 0, width, height);

			data.forEach(function(o) {
				var topo = topojson.feature(communes, o).features;

				canvas.strokeStyle = 'rgba(100, 100, 100, 0.2)';
				drawPath(topo, canvas);
			});
		};
		drawCommunes(d3.map(communes.objects).values());
});

var drawPath = function(d, canvas, fill) {
    d.forEach(function(d) {
		switch (d.geometry.type) {
			case 'Polygon':
				d.geometry.coordinates.forEach(function(c, i) {
					drawPolygon(c, canvas, fill);
				});
				break;
			case 'MultiPolygon':
				d.geometry.coordinates.forEach(function(c, i) {
					c.forEach(function(d, j) {
						drawPolygon(d, canvas, fill);
					});
				});
				break;
			default:
				// I have no idea how to render anything else.
				break;
		}
    });
};

var drawPolygon = function(d, canvas, fill) {
	canvas.beginPath();
	if (fill) {
		if (fill instanceof Function) {
			canvas.fillStyle = fill(d).toString();
		} else {
			canvas.fillStyle = fill;
		}
	}

	d.forEach(function(c, i) {
		var coord = projection(c);
		if (null == coord || coord == [NaN, NaN]) {
			return;
		}
		if (i == 0) {
			canvas.moveTo(coord[0], coord[1]);
		} else {
			canvas.lineTo(coord[0], coord[1]);
		}
	});
	if (fill) {
		canvas.closePath();
		canvas.fill();
	}
	canvas.stroke();
};


</script>
</body>
